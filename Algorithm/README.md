# Algorithm

## 1. 정렬 알고리즘
-  정렬이란? 순서 없이 배열된 자료들을 값 또는 순서에 따라 재 배열하는 것을 말합니다. 자료를 정렬하는 데 사용하는 자료의 값을 키(Key)라고 합니다. 예를 들면, 파일 크기, 수정 날짜, 이름 등이 있습니다. 또 정렬 순서는 오름차순(ASC)과 내림차순(DESC)가 있습니다.

- 많은 정렬 알고리즘 중에 하나를 선택하는 기준으로는 1) 효율성과 2) 안전성이 있습니다. 
- 1) 효율성은 얼마만큼 빠르게 정렬하는 가를 말합니다. 보통 연산 횟수로 계산되는데 정렬 알고리즘은 값을 비교하는 연산과 자료의 위치를 변경하는 이동 연산으로 구성됩니다.

<div align=center> 

![bigO](https://upload.wikimedia.org/wikipedia/commons/thumb/7/7e/Comparison_computational_complexity.svg/512px-Comparison_computational_complexity.svg.png)

</div>

- 2) 안정성은 키 값이 같은 자료들이 입력한 순서를 그대로 정렬하는가를 말합니다. 기존에 정렬한 내용이 유지되는지를 확인하면 됩니다. 먼저 정렬된 내용이 유지되지 않는다면 불안정 정렬입니다.

![](/assets/images/algorithm/sorted_1.png)


### 1) 선택정렬 알고리즘
- 선택정렬 알고리즘이란? 정렬되지 않은 전체 자료 중에서 해당 위치에 맞는 자료를 선택하여 위치를 교환하는 알고리즘입니다. 글로는 이해가 잘 안되지만 그림으론 굉장히 간단한 알고리즘입니다.

![](/assets/images/algorithm/sorted_2.png)

: {80, 75, 10, 60, 15, 49, 12, 25}라는 배열이 있다면 전체를 한 번 검색한 후 가장 작은 값을 첫 번째 인덱스와 위치교환합니다.

![](/assets/images/algorithm/sorted_3.png)

: 다음으로 정렬 전인 배열 중 가장 작은 값을 찾고 두 번째 인덱스와 위치교환을 합니다. 이와 같은 방법으로 마지막 인덱스 전까지 반복합니다.

![](/assets/images/algorithm/sorted_4.png)

: 마지막 인덱스는 가장 큰 값이 되므로 그대로 두면 됩니다.

 - 실행결과 (출처 : 나무위키 정렬알고리즘)
 <div align=center>
  
 ![출처 나무위키](http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif)
 
 </div>
 
 [Source-Swift](/Algorithm/source/sorted/selected.swift)

### 선택알고리즘의 특징
- 이 알고리즘은 1) 이동하는 자료를 선택하고 2) 교환하는 연산 2가지로 구성되어 있습니다. 또 선택과 교환의 갯수대로 n번만큼 루프문을 돌려야하므로 빅오표기법으론 O((n-1) + (n-2) + ... + 3 + 2 + 1) = O(n(n-1) / 2) = O(n^2)이 됩니다. 또 자료 교환시 3번의 이동연산을 포함하기에 O(3(n-1)) = O(n)이 됩니다. 따라서 O(n^2 + n) = O(n^2)이 되고 이는 효율성이 낮은 알고리즘입니다. 또 자료의 교환이 계속되어 정렬의 안전성을 유지할 수 없습니다.

- 알고리즘들 중에 사람의 정렬 방법과 가장 많이 닮은 알고리즘입니다.

- 효율성 : O(n^2) , 안정성 : 유지불가함.

[뒤로](https://github.com/bugkingK/Welcome-My-Github)/[위로](#algorithm)


### 2) 퀵 정렬 알고리즘
 - 퀵 정렬 알고리즘이란? 중심 값(피봇: Pivot)을 기준으로 두 자료의 키 값을 비교하여 위치를 교환하는 방법입니다.
 
 ![](/assets/images/algorithm/sorted_5.png)

 : 먼저 오름차순 정렬을 기준으로 left는 피봇보다 작은 값이, right는 큰 값이 와야합니다.
 
 ![](/assets/images/algorithm/sorted_6.png)
 
 : 피봇보다 작고, 큰 값을 찾았다면 두 값을 위치교환합니다. 교환 완료 시 left는 오른쪽으로, right는 왼쪽으로 이동하여 두 left와 right가 같은 것을 가리킬 때까지 반복합니다. 
 
 ![](/assets/images/algorithm/sorted_7.png)
 
 : 같은 장소를 가리킨다면 그 곳과 피봇을 위치교환합니다.
 
 ![](/assets/images/algorithm/sorted_8.png)
 
 : 피봇 기준으로 왼쪽은 피봇보다 작은 값이 오른쪽은 큰 값이 위치하게 됩니다. 마지막으로 작은 값 배열과 큰 값 배열 각각 같은 방식으로 퀵 정렬을 실행하면 정렬이 완료됩니다. 단 배열의 원소 갯수가 1이하라면 정렬할 필요가 없습니다.

- 실행결과 (출처 : 나무위키 정렬알고리즘)

![나무위키](http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif)


[Source-Swift](/Algorithm/source/sorted/quick.swift) / [Source-fix-Swift](/Algorithm/source/sorted/quick-fix.swift)

### 퀵 정렬 알고리즘의 특징
 - 피봇을 기준으로 2개의 부분집합으로 나눠 정렬하므로 n/2, n/4, n/8, ... , n/2^k와 같이 줄어들어 평균 logn의 연산 횟수가 필요합니다. 또 매 정렬마다 n번의 비교가 필요하여 시간복잡도는 평균 O(nlogn)이 됩니다. 하지만 데이터의 분포가 균형적으로 있다면 O(nlogn)이 맞지만 불균형적으로 분포되어 있다면 O(n^2)의 효율을 갖게 됩니다. 또 퀵정렬은 자료의 교환이 계속일어나기에 정렬의 안전성을 유지할 수 없습니다.
 
 - 사실 시간복잡도가 최악인 경우는 퀵 정렬을 사용할 필요가 없어집니다. 이를 해결하기 위해 피봇의 위치를 랜덤으로 정해줍니다. 

 - 효율성 : 평균O(nlogn), 최악(n^2), 안정성 : 유지불가함.

[뒤로](https://github.com/bugkingK/Welcome-My-Github)/[위로](#algorithm)


### 3) 병합 정렬 알고리즘
 - 병합 정렬이란? 기존 자료를 원소의 갯수가 동일한 부분집합으로 분할하고 분할된 각 부분 집합을 병합하면서 정렬 작업을 완성하는 방식으로 정렬합니다. 또 몇 개의 부분집합으로 나누냐에 따라 종류가 나뉘게 되는데, 2개의 정렬된 자료집합을 병합하는 경우 2-way 병합, n개일 땐 n-way 병합입니다. 저는 2-way 병합을 공부했습니다. 작동원리는 다음과 같습니다.
 
 ![](/assets/images/algorithm/sorted_9.png)
 
 : 먼저 하나의 집합을 원소의 개수와 같은 여러 부분 집합으로 분할합니다.
 
 ![](/assets/images/algorithm/sorted_10.png)
 
 : 원소의 집합들을 다시 하나의 집합으로 되돌리며 병합을 실시합니다. 병합 과정은 다음과 같습니다.
 
 ![](/assets/images/algorithm/sorted_11.png)
 
 : 먼저 집합들의 첫 인덱스를 가리키고 가리킨 두 인덱스의 값을 비교합니다. 둘 중 작은 값은 선택되게 됩니다. 선택되면 다음 인덱스를 가리킵니다.
 
 ![](/assets/images/algorithm/sorted_12.png)
 
 : 둘 중 작은 값을 선택합니다. 이와 같은 행동을 반복합니다.
 
[Source-Swift](/Algorithm/source/sorted/merge.swift) 

### 병합 정렬 알고리즘의 특징
 - 기존 자료를 원소의 갯수가 동일한 부분집합으로 분할하고 또 부분집합들을 병합하므로 O(logn)이 됩니다. 병합할 때 모든 원소를 비교하므로 O(nlogn)이 됩니다. 비교할 때 모든 원소를 다 거치므로 최선, 평균, 최악 모두 O(nlogn)이 됩니다. 하지만 추가 메모리공간이 필요하고 이동횟수가 많다는 단점이 있습니다. 배열 대신 연결리스트를 사용하여 이동 대신 연결포인터만 변경하여 성능을 높일 수 있다합니다. 기존의 선택과 퀵 정렬은 교환 기반이라 안전성을 유지하지 못하지만 병합 정렬은 병합을 기반으로 하여 안전성을 유지할 수 있습니다.


[뒤로](https://github.com/bugkingK/Welcome-My-Github)/[위로](#algorithm)



## 2. 검색 알고리즘

### 이진 검색 트리
- 자식 노드가 2개 이하인 검색 트리를 말합니다. 가운데 루트노드가 존재하여 루트노드 기준으로 왼쪽 노드는 루트노드의 값보다 작고 오른쪽노드는 값이 큽니다. 모든 노드는 유일한 키 값을 가질 뿐아니라 효율적인 검색이 가능합니다.

![](/assets/images/algorithm/search_1.png)

- 이진 검색 트리는 균형, 불균형 이진 검색 트리가 존재합니다. 이는 데이터를 노드에 저장하는 순서에 따라 발생하게 됩니다. 

~~~
(1) 18->7->3->12->26->21->31     (2) 3->7->12->18->21->26->31
~~~

- 같은 데이터라도 저장순서에 따라 검색 성능이 달라집니다. 데이터 31를 검색시 (1)은 3번, (2)는 6번의 비교 연산이 필요합니다. 이를 시간복잡도로 나타내면 균형 이진 검색트리는 O(logn), 불균형은 O(n)입니다. 불균형을 해결하기 위해서 AVL트리와 레트-블랙 트리등이 존재합니다. 불균형을 해소하더라도 트리의 높이 문젝 남았습니다. 예를 들어 천 만개의 데이터를 저장한다면 트리의 높이는 24가 됩니다. 트리의 높이가 높아지며 성능이 저하되게됩니다.

### 트리의 높이가 높아질 수록 성능이 떨어지는 이유는 뭘까요?
- 성능이 떨어지는 경우는 트리 노드가 디스크에 저장된 경우입니다. 예를 들어, 데이터베이스에서는 저장하는 자료 1개의 크기가 크기 때문에 보통 노드 단위 디스크에 저장해둡니다. 그리 비교연산이 필요한 경우 해당 노드를 디스크에 읽어들여 메모리로 적재합니다. 노드 별 비교연산을 위해서 먼 디스크를 읽는 연산이 필요합니다. 따라 트리으 높이가 높아지면 디스크에서 자료를 읽는 횟수 증가하여 성능이 저하됩니다.

![](/assets/images/algorithm/search_2.png)

- 한 줄 요약 : 검색 시 노드 별 비교 전 데이터를 읽어와야 하는데 트리 높이가 높아질 수록 읽어올 데이터가 많아져 성능이 떨어진다.


[뒤로](https://github.com/bugkingK/Welcome-My-Github)/[위로](#algorithm)


### 다원 검색 트리
 - 각 노드가 여러 개의 자료를 가질 수 있고 자식 노드의 개수 또한 2보다 큰 값을 설정할 수 있습니다. 다원 검색 트리는 이진트리의 문제점인 높이를 해결하 수 있습니다.
 
![](/assets/images/algorithm/search_3.png)

 #### 다원 검색은 5가지의 특성을 갖습니다.
 
 - 1) 각 노드는 0에 최대 m개의 서브트리를 가집니다. (m은 하나의 노드 가질 수 있는 자식 노드의 최대 개수입니다.)

 ![](/assets/images/algorithm/search_4.png)
 
 - 2) k개의 자식 노드를 가지는 노드는 (k-1)개의 자료를 가집니다.(단, k<=m)
 
 ![](/assets/images/algorithm/search_5.png)

 : 여기서 m은 노드 안 점의 개수이고 k는 자식 노드의 개수인데 0<=k<=m 개까지 갖을 수 있습니다. 노드가 저장할 수 있는 데이터는 k-1개입니다.(단, k<=m), 또 각 노드 저장할 수 있는 최대 자료의 개수는 m-1개 입니다.
 
 - 3) 각 노드 안에 있는 자료는 검색 키로 정렬됩니다. key1 <= key2 <= ... <= key(k-1)
 : 노드 안 데이터들은 오름차순, 내림차순 등으로 정렬됩니다.
  
  
 - 4) 다음 조건을 항상 만족합니다. key i <= (i번째 서브트 내의 모든 키 값) < key(i+1)
 
 ![](/assets/images/algorithm/search_6.png)
 
 - 5) 모든 서브트리는 m-원 검색 트리입니다.
 
 ![](/assets/images/algorithm/search_7.png)
 
 - 다원 검색 트리 또한 이진 검색 트리와 마찬가지로 트리의 균형을 유지하지 못합니다. 그러다보니 자료 추가 순서와 특징에 따라 불균형이 발생합니다. 이를 해결한 것이 B-트리입니다.
 
 [뒤로](https://github.com/bugkingK/Welcome-My-Github)/[위로](#algorithm)
 


## 3. 해시 알고리즘
 - 해시는 고기와 감자를 잘게 다져서 먹는 음식입니다. 잘게 잘라 원래 모습을 알 수 없듯이, 계산 과정을 거치면서 작아진 값을 말합니다. 해시가 만들어지는 과정은 다음과 같습니다. 데이터(keys)를 해시함수(hash function)에 넣어 return 받는 값이 해시입니다.
 
![](/assets/images/algorithm/hash_1.png)

해시는 검색알고리즘에서 자주사용합니다. 그렇다면 해시함수에 의해 작아진 해시값으로 어떻게 빠른 검색을 할 수 있을까요? 해시 검색의 구조는 다음과 같습니다.

![](/assets/images/algorithm/hash_2.png)

해시 함수의 결과값인 해시 값 자체가 해시테이블의 주소값이 되어 빠른 검색이 가능해집니다. 일반적으로 해시테이블은 주소로 빠로 접근할 수 있는 배열을 사용합니다. 또 테이블은 N개의 버킷으로 구성되어 있는데 버킷이란 해시 테이블에서 자료를 저장하는 단위입니다. 하나의 고유한 해시(주소)에 대응하여 실제 자료가 저장되는 곳입니다.

 ### 계산검색 방법 vs 비교검색 방법
 
 - 계산검색 방법이란?
 해시검색이 대표적인 예인데 해시검색은 해시함수의 결과 값이 곧 주소값이기에 시간복잡도가 최소 O(1)입니다. 자료의 개수 n과 상관없이 특정 상수를 시간내에 계산할 수 있습니다. 이처럼 검색 키에 대해서 주소를 직접 계산하고 검색하는 것입니다.
 
 - 비교검색 방법이란?
 순차검색, B-트리 등이 있습니다. 이러한 알고리즘은 검색 키 값을 하나씩 비교하여 찾아냅니다. 가장 빠른 시간 복잡도는 평균 O(logn)입니다. 비교하는 자료의 수가 많아질 수록 검색 시간이 느려집니다.
 
 ### 해시 테이블에 자료추가하기
 자료를 추가하는 방법은 총 3단계로 이루어져 있습니다. 1. 주소계산 2. 해시테이블 확인 3. 자료 저장입니다. 
 
 ![](/assets/images/algorithm/hash_3.png)
 
 1. 주소계산 : 검색 키를 해시함수를 통해 분해 및 조립을 하여 주소값을 의미하는 해시를 만듭니다.
 
 2. 해시테이블 확인 : 해시를 저장하기 전에 해당 주소에 값이 있는지 확인을 합니다. 
 
 3. 자료 저장 : 자료를 저장할 수 있는 주소를 찾았다면 값을 저장합니다.
 
 #### 해시자체가 주소인데 바로 저장하지 않고 확인하는 이유는 뭘까요?
  이유는 해시함수의 결과에 의해 같은 값이 나오기 때문입니다. 그래서 자신의 주소값에 기존에 있던 값이 존재할 수 있습니다. 이러한 경우를 충돌(collision)이라 합니다.  

 ### 자료검색
 자료검색은 자료 추가 과정에서 자료 저장만 안하면 됩니다. 또 검색은 성능이 좋아야하는데 이를 결정하는 것은 해시함수와 관련이 있습니다.
 
 ![](/assets/images/algorithm/hash_4.png)
 
 ### 해시함수
 좋은 해시함수는 검색을 빠르게 해줍니다. 이를 판단하는 척도로 1. 충돌발생 빈도 2. 해시 테이블 사용률과 3. 해시함수 계산 속도입니다.
 
 1. 충돌발생 빈도 : 충돌발생 시 충돌 처리를 해줘야하므로 최대한 적은 것이 좋습니다.
 2. 해시 테이블 사용률 : 테이블이 고르게 분포되야 저장 공간 활용 효율면에서 좋습니다.
 3. 해시함수 계산 속도 : 빠른 해시함수는 해시검색 속도를 감소시킵니다.
 
 해시함수의 종류로는 1. 나머지함수 2. 접지함수 3. 중간제곱함수 4.숫자분석 기반의 해시함수 등이 있습니다.
 
 1. 나머지함수
 검색키 k를 해시 테이블의 크기 m으로 나눈 나머지를 해시로 사용합니다.
 ~~~
    hash = k % m
 ~~~
 나머지 함수는 테이블의 크기 m이 소수일 수록 충돌 발생 빈도가 낮아집니다. 충돌 발생 빈도가 낮다는 뜻은 해시 테이블 사용률 또한 높아진다는 뜻입니다. 따라서 설계시 해시 테이블이 100이라면 100대신 101을 사용하는 것이 좋습니다.
 
 2. 접지함수
 검색 키를 먼저 분해하고 분해된 부분들을 조합하여 해시를 사용합니다. 보통 검색 키의 크기가 해시 테이블의 크기보다 클 때 사용합니다.(접지라는 이름을 쓰는 이유가 검색 키가 너무 커서 접어서 쓴다 해서 붙여진 이름인거 같습니다.) 접는 방법에 따라 종류가 나뉘는데 대표적인 1.이동접지 함수와 2. 경계접지 함수를 알아보겠습니다.
 
 - 1. 이동접지함수
 분해된 부분들을 오른쪽 정렬을 한 후 각 부분을 조합하는 접지 방법을 말합니다.
 
 ![](/assets/images/algorithm/hash_5.png)
 
 만약 해시값이 m의 값을 넘는다면 초과된 자릿수를 버립니다.
 
 - 2. 경계접지함수
 이동접지함수와 분해, 더하기 부분은 같으나 이동하는 부분이 다릅니다. 경계부분을 반전시켜 값을 더합니다.
 
 ![](/assets/images/algorithm/hash_6.png)
 
3. 중간제곱함수
검색 키의 일부분에서 해시를 채취합니다.
~~~
예) 검색 키 k : 9415
해시 테이블 크기 m : 9999 일때

검색 키의 제곱 : 9451  * 9451 = 89321401, 제곱의 결과의 가운데 4자리가 해시값입니다. 89(3214)01 / 3214 = 해시값
~~~

4. 숫자분석 기반의 해시함수
숫자분석 기반이란 뜻은 검색 키가 어떠한 특징이 있는지 검색 키의 특징을 알아낸다는 뜻입니다. 즉, 이 함수는 충돌이 발생할 가능성이 낮아지도록 검색 키가 가지는 '값의 분포'를 이용한 함수입니다. 예를 들면 학번에서 201331003 중 2013은 입학년도 나머지 5자리는 학과번호와 학생고유번호입니다. 이를 그래프로 그린다면

 ![](/assets/images/algorithm/hash_7.png)
 
입학년도가 같다면 한 곳에 집중되어 충돌 가능성이 높아집니다. 하지만 나머지 5자리로 한다면 고유한 번호이기에 충돌 가능성이 낮아지게 됩니다. 해시함수는 이외에도 진법변환함수, 비트 추출함수, 가상 난수 기법등이 있습니다.
 
 [뒤로](https://github.com/bugkingK/Welcome-My-Github)/[위로](#algorithm)


#### 만약 검색 키가 정수가 아니라 문자열이라면?
지금까지는 검색 키가 정수였습니다. 그렇다면 문자열은 어떻게 처리할까요?
1. 첫 문자 아스키코드 사용
예를들면 검색 키가 ABC일때 A=65 이므로 해시는 65가 됩니다. 첫 글자만 같으면 계속 충돌이 생기므로 효율이 좋지 못합니다.

2. 문자열의 모든 아스키코드 값 더하기
검색 키가 ABC일때 65+66+67 = 198이 해시가 됩니다. 이 또한 검색키가 CBA라면 67+66+65 = 198로 둘의 해시는 충돌하게 됩니다.

3. 문자의 위치를 고려한 코드 값 더하기(허너의 방법)
검색 키가 ABC일때 ((65*31)+66)*31 + 67 = 64578이고 CBA는 ((67*31)66)*31 + 65 = 66498입니다. 둘의 값은 충돌하지 않습니다. 만약 오버플로우가 발생 시 자릿수를 제거함으로써 조치를 취할 수 있습니다.

### 충돌해결
좋은 해시함수로 충돌을 제거하더라도 해시값이 같아 충돌이 나기마련입니다. 이를 해결하는 여러방법이 있지만 2가지 방법을 공부했습니다. 1. 충돌이 일어난 키 값을 비어 있는 다른 주소를 찾아 저장하는 개방주소기법 2. 여러 개의 항목을 저장할 수 있도록 해시 테이블의 구조를 변경하는 체이닝 기법이 있습니다.

1. 개방주소기법
조사법이라고도 불리며 해시함수가 계산한 주소가 비어있는지 확인하고 비어 있다면 값을 저장하고 비어 있지 않다면 빈 주소검색을 합니다. 만약 해시테이블이 꽉 찬경우는 중지합니다. 빈 주소를 검색하는 방법으론 1) 선형조사법 2) 제곱조사법 3) 이중해싱 등이 있습니다.

- 1) 선형조사법
충돌이 발생할 경우 주소를 일정한 상수만큼 증가시켜 다시 조사합니다. 충돌 위치와 근접해 있다보니 다음 충돌 또한 근처에 발생할 수 밖에 없어 클러스트(군집화)현상이 발생하기 쉽습니다.
~~~
h(k) = (k + try_count) mod m
~~~

- 2) 제곱조사법
충돌이 발생할 경우 주소를 조사 횟수의 제곱만큼 증가시켜 다시 조사하는 방법입니다. 1차 충돌은 1을 더하고 2차 충돌은 4(2*2) n차 충돌은 n^2을 더합니다.
~~~
h(k) = (k + try_count * try_count) mod m
~~~
선형조사법에 비해 군집화 현상 발생 가능성이 낮으나 가능성은 있습니다. 또 해시테이블의 모든 주소를 조사하려면 해시 테이블의 크기가 반드시 소수여야 하는 제약도 있습니다.

- 3) 이중 해시
충돌 발생 시 원래의 해시함수 말고 다른 해시함수를 이용해 조사합니다. 어떤 해시함수에 따라 기법이 달라지는데 그 중 조사간격 기법은 다음과 같습니다.
~~~
(조사 간격) = m - (k mod m)
~~~
이중해싱은 추가 해시함수로 같은 해시값을 가지더라도 조사 순서를 달리하여 군집화 발생가능성을 낮췄습니다.


2. 체이닝 기법
해시 테이블의 각 버킷에 하나 이상의 검색 키를 저장하는 방법입니다. 체이닝은 각 주소에 연결리스트를 사용하여 충돌이 발생할 때 동적으로 여러 개의 검색 키 값을 저장할 수 있게합니다.

 ![](/assets/images/algorithm/hash_8.png)
 
기존 해시테이블에 값을 저장했다면 그 값 대신 연결리스트의 주소값을 넣어줍니다.

 ![](/assets/images/algorithm/hash_9.png)
 
해시함수의 결과 같은 주소값이 나왔을 때 해당 값을 연결리스트에 추가해줌으로 충돌을 해결합니다. 해시를 저장하는 방법은 인덱스 0부터 추가하거나 마지막 부터 추가합니다. 또 오름차순, 내림차순으로 추가하는 등 여러 방법이 있습니다.

 [뒤로](https://github.com/bugkingK/Welcome-My-Github)/[위로](#algorithm)