# CommonTheory

### 트랜잭션
 - 실행해야할 여러 개의 단위 작업을 터널로 연결하듯 하나로 묶어 원자성을 부여함으로써 완전한 성공 또는 완전한 실패를 보장합니다. 최종성공 시 : 커밋, 하나라도 실패시 롤백합니다.
 
#### 트랜잭션의 4대 원칙(ACID)
 1. 원자성(A) : 하나의 트랜잭션 내에 정의된 작업들은 모두 수행되었는지, 아니면 아무것도 수행되지 않아야한다는 가장 기본적인 원칙입니다. "All or Nothing"
 2. 일관성(C) : 성공적으로 수행된 트랜잭션은 정당한 데이터만을 데이터베이스에 반영해서 무결성을 유지해야한다는 원칙입니다.
 3. 격리성, 고립성(I) : 각각의 트랜잭션은 독립성을 지녀야하며, 하나의 트랜잭션이 실행되는 도안 트랜잭션 내부에 다른 트랜잭션이 접근할 수 없어야 한다는 원칙입니다.
 4. 지속성(D) : 트랜잭션이 일단 성공적으로 완료되어 데이터베이스에 커밋되고 나면, 하드웨어나 소프트웨어에 오류가 발생했더라도 트랜잭션의 결과가 데이터베이스에 계속 보존되어야 한다는 원칙입니다.
 
 
 [swift-libsqlite3 사용하기]()
 </br>
 [swift-fmdb 사용하기]()
 
 ### SQL 실행원리
  - SQL문이 실행되기 위해선 총 4단계를 거칩니다. 1. 구문분석(Parsing) 2. 최적화(Optimizing) 3. 컴파일(Compilation) 4. 실행(Execution)이 그 단계입니다. 하나씩 살펴보겠습니다.
  </br>
 1. 구문분석(Parsing) : SQL 구문의 문법과 의미가 정확한지 판단합니다. 이상이 없다면 내부 캐시에 동일한 문법이 있는지 검색한 후 있다면 2, 3단계를 생략하고 없다면 새로 저장합니다.
 2. 최적화(Optimizing) : 데이터 분포통계나 테이블의 관계정보를 바탕으로 SQL문에 최적화된 실행계획을 수립하는 단계입니다. db에 내장된 옵티마이저(최적화기)는 계획을 검토하고 최적의 계획을 선택합니다.
 3. 컴파일(Compilation) : 옵티마이저를 통해 선택된 계획을 바탕으로 계획을 생성하는 단계입니다.
 4. SQL 실행(Execution) : 생성된 실행 계획을 DBMS 엔진에서 수행하여 결과를 사용자에게 반환하는 단계입니다.
 
 ### Statement vs Prepared Statement
 - 구글링을 해보면 Prepared Statement가 Statement에 비해 CPU 효율이 더 좋다라고 하는데 어떻게 효율이 좋을까요? Prepared Statement는 파레토의 법칙을 최적화하기 위함입니다. 그렇다면 파레토의 법칙은 무엇일까요? 전체의 80%는 자주 사용되는 20%에의 한다라는 법칙입니다. SQL문의 반복 수행되는 과정의 비효율성을 줄이고 성능을 향상 시킨다는데 그렇다면 SQL문의 어디서 비효율이 발생할까요? 이를 알기위해선 [SQL 실행원리](#sql-실행원리)를 알고 있어야합니다. 
 
 - 내부 캐시에 동일한 문법이 있다면 1->4로, 계획이 없다면 1->2->3->4를 수행하고 실행계획은 캐싱해둡니다. 
 - SQL문의 비효율은 여기서 발생합니다. 먼저 Statement 예제를 살펴보겠습니다.
 

 ~~~ 
 Statement 예제
     SELECT depart_title FROM department WHERE depart_cd = 1;
     SELECT depart_title FROM department WHERE depart_cd = 2;
 ~~~
 : 두 구문은 WHERE 절을 제외한 모든 정보가 같지만 해시함수 결과 해시값은 전혀다른 값을 갖습니다. 
 
 ~~~ 
 Prepared Statement 예제
     SELECT depart_title FROM department WHERE depart_cd = ?; (인자값 1을 매개변수로 전달)
     SELECT depart_title FROM department WHERE depart_cd = ?; (인자값 2을 매개변수로 전달)
 ~~~
 : 두 구문이 모두 같아 해시값이 서로 같습니다.
 
 - 해시값이 다르다는 말은 비슷한 구문을 사용하더라도 서로 다른 실행계획을 생성해야한다는 의미이고, 해시값이 같다는 말은 실행계획을 생성할 필요가 없고 재사용이 가능하다는 뜻입니다. 이와 같이 Prepared Statement는 SQL 실행원리에서 최적화와 컴파일을 생략하고 넘어갈 수 있습니다. 이외에도 다른 장점을 갖습니다.
 
 1. SQL을 여러번 실행하더라도 SQL을 컴파일하고 최적화하는 오버헤드는 단 한 번만 발생합니다. (Statement 방식은 매번 발생)
 2. 텍스트 형태의 SQL문을 생성하는 것이 아니므로 매개변수를 변조하여 SQL문을 변형하는 SQL Injection 위험으로부터 안전합니다.
 3. SQL 문에는 위치홀더만 포함되기 때문에, 인자값에 대한 ?(쿼우팅)처리가 필요없습니다.
 
 - 하지만 꼭 Prepared Statement가 우수한 것은 아닙니다.
 1. 최적화 단계에서 인자 값의 특성이 반영되지 않으므로 실제 데이터 분포에 대한 히스토그램 데이터를 활용할 수 없어 비효율적인 실행계획이 생성될 수 있습니다.
 2. 단발성 쿼리의 경우 DBMS에 대한 추가 왕복 작업으로 인해 불필요한 리소스가 소비될 수 있습니다.
 
 - 따라서 Statement나 Prepared Statement를 이해하고 필요에 따라 적절한 방식을 선택하는 것이 중요합니다. 다만 앱의 특성상 SQL문을 반복적으로 실행하는 경향이 많아 Prepared Statement 방식이 더 좋습니다.
 
 
 
